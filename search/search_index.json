{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>qontrol is a quantum optimal control package built on top of dynamiqs. You can define your controls however you would in dynamiqs, specifying only how to update the Hamiltonian at each optimizer step. dynamiqs also has strong native support for batching, which qontrol can leverage e.g. for randomizing over uncertain parameters.</p>"},{"location":"#installation","title":"Installation","text":"<p>For now we support only installing directly from github <pre><code>pip install git+https://github.com/dkweiss31/qontrol\n</code></pre></p> <p>Requires Python 3.10+</p>"},{"location":"#quick-example","title":"Quick example","text":"<p>Optimal control of a Kerr oscillator, with piece-wise constant drives on the I and Q quadratures and optimizing for a <code>Y</code> gate</p> <p><pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport optax\nimport qontrol as ql\n\n# hyper parameters\nn = 5  # system size\nK = -0.2 * 2.0 * jnp.pi  # Kerr nonlinearity\ntime = 40.0  # total simulation time\ndt = 2.0  # control dt\nseed_amplitude = 1e-3  # pulse seed amplitude\nlearning_rate = 1e-4  # learning rate for optimizer\n\n# define model to optimize\na = dq.destroy(5)\nH0 = 0.5 * K * dq.dag(a) @ dq.dag(a) @ a @ a\nH1s = [a + dq.dag(a), 1j * (a - dq.dag(a))]\n\n\ndef H_pwc(drive_params):\n    H = H0\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, drive_params[idx], _H1)\n    return H\n\ninitial_states = [dq.basis(n, 0), dq.basis(n, 1)]\n# We can track the behavior of observables by passing them to the model. Here we track\n# the state populations\nexp_ops = [dq.basis(n, idx) @ dq.dag(dq.basis(n, idx)) for idx in range(n)]\nntimes = int(time // dt) + 1\ntsave = jnp.linspace(0, time, ntimes)\nmodel = ql.sesolve_model(H_pwc, initial_states, tsave, exp_ops=exp_ops)\n\n# define optimization\nparameters = seed_amplitude * jnp.ones((len(H1s), ntimes - 1))\ntarget_states = [-1j * dq.basis(n, 1), 1j * dq.basis(n, 0)]\ncost = ql.cost.coherent_infidelity(target_states=target_states, target_cost=0.001)\noptimizer = optax.adam(learning_rate=0.0001)\noptions = ql.OptimizerOptions(\n    save_states=False, progress_meter=None, verbose=False, plot=True, plot_period=5\n)\n\n# run optimization\nopt_params = ql.optimize(parameters, cost, model, optimizer=optimizer, options=options)\n</code></pre> You should see the following oputput, tracking the cost function values, pulse, pulse fft and expectation  values over the course of the optimization   We initialize the <code>sesolve_model</code> which when called with <code>parameters</code> as input runs <code>sesolve</code> and returns that result as well as the updated Hamiltonian. These are in turn passed to  the cost functions, which tell the optimizer how to update <code>parameters</code>.</p>"},{"location":"#jump-in","title":"Jump in","text":"<p>If this has piqued your interest, please see the example jupyter notebooks that demonstrate different use cases of <code>qontrol</code>, including optimizing gates on a qubit to be robust to frequency variations as well as performing time-optimal control and master-equation optimization. More examples coming soon!</p>"},{"location":"#citation","title":"Citation","text":"<p>If you found this package useful in academic work, please cite</p> <pre><code>@unpublished{qontrol2024,\n  title  = {qontrol: Quantum optimal control based on dynamiqs, diffrax and JAX},\n  author = {Daniel K. Weiss},\n  year   = {2024},\n  url    = {https://github.com/dkweiss31/qontrol}\n}\n</code></pre> <p>Also please consider starring the project on github!</p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#how-can-i-incorporate-drive-constraints-as-opposed-to-costs","title":"How can I incorporate drive constraints (as opposed to costs)?","text":"<p>Constraints can be incorporated at the level of the Hamiltonian function:</p> <pre><code>a = dq.destroy(5)\nH0 = dq.dag(a) @ dq.dag(a) @ a @ a\nH1s = [a + dq.dag(a), 1j * (a - dq.dag(a))]\nmax_amp = 2.0 * jnp.pi * 0.01\ntsave = jnp.linspace(0, 40.0, 31)\nparameters = jnp.zeros((len(H1s), len(tsave) - 1))\n\ndef H_pwc(drive_params):\n    H = H0\n    for idx, _H1 in enumerate(H1s):\n        clipped_drive = jnp.clip(\n            drive_params[idx],\n            a_min=-max_amp,\n            a_max=max_amp,\n        )\n        H += dq.pwc(tsave, clipped_drive, _H1)\n    return H\n</code></pre>"},{"location":"FAQ/#how-do-i-initialize-random-initial-pulses","title":"How do I initialize random initial pulses?","text":"<p>This can be done by utilizing existing rng functionality from jax. Lets create a random initial guess for the <code>pwc</code> control above with values between +1 and -1. <pre><code>key = jax.random.PRNGKey(31)\nparameters = 2.0 * jax.random.uniform(key, (len(H1s), len(tsave) - 1)) - 1.0\n</code></pre></p>"},{"location":"FAQ/#how-do-i-access-the-saved-information","title":"How do I access the saved information?","text":"<p>If a <code>filepath</code> is passed to <code>optimize</code>, the parameters from each epoch are saved along with the individual values of each cost function and the total cost. This data can be extracted via (assuming the data has been saved in the file 'tmp.h5py')</p> <p><pre><code>data_dict, param_dict = ql.extract_info_from_h5('tmp.h5py')\n</code></pre> where <code>data_dict</code> contains the optimized parameters as well as cost function info, and <code>param_dict</code> contains the options passed to <code>optimize</code>.</p>"},{"location":"FAQ/#you-havent-defined-my-favorite-cost-function","title":"You haven't defined my favorite cost function?!","text":"<p>No worries! See the API of <code>ql.custom_cost()</code> as well as <code>ql.custom_control_cost()</code> for examples of how to define custom cost functions.</p>"},{"location":"api/","title":"Python API","text":"<p>The qontrol Python API consists of the function optimize which performs optimal control, and various models that can be optimized including SESolveModel and MESolveModel. There are additionally various utility functions and classes that help to define an optimization routine (cost functions, file input output, options, etc.)</p>"},{"location":"api/#optimization","title":"Optimization","text":""},{"location":"api/#qontrol.optimize.optimize","title":"<code>optimize(parameters, costs, model, *, optimizer=optax.adam(0.0001, b1=0.99, b2=0.99), solver=Tsit5(), gradient=None, options=OptimizerOptions(), filepath=None)</code>","text":"<p>Perform gradient descent to optimize Hamiltonian parameters.</p> <p>This function takes as input <code>parameters</code> which parametrize a <code>model</code> when called performs time-dynamics simulations using dynamiqs. How to update <code>parameters</code> is encoded in the list of cost functions <code>costs</code> that contains e.g. infidelity contributions, pulse amplitude penalties, etc.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>_(dict or array-like)_</code> <p>parameters to optimize over that are used to define the Hamiltonian and control times.</p> required <code>costs</code> <code>_(list of Cost instances)_</code> <p>List of cost functions used to perform the optimization.</p> required <code>model</code> <code>_(Model)_</code> <p>Model that is called at each iteration step.</p> required <code>optimizer</code> <code>_(optax.GradientTransformation)_</code> <p>optax optimizer to use for gradient descent. Defaults to the Adam optimizer.</p> <code>adam(0.0001, b1=0.99, b2=0.99)</code> <code>solver</code> <code>_(Solver)_</code> <p>Solver passed to dynamiqs.</p> <code>Tsit5()</code> <code>gradient</code> <code>_()Gradient_</code> <p>Gradient passed to dynamiqs.</p> <code>None</code> <code>options</code> <code>_(OptimizerOptions)_</code> <p>Options for grape optimization and dynamiqs integration.</p> <code>OptimizerOptions()</code> <code>filepath</code> <code>_(str)_</code> <p>Filepath of where to save optimization results.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array | dict</code> <p>optimized parameters from the final timestep</p>"},{"location":"api/#cost-functions","title":"Cost functions","text":""},{"location":"api/#qontrol.cost.coherent_infidelity","title":"<code>coherent_infidelity(target_states, cost_multiplier=1.0, target_cost=0.005)</code>","text":"<p>Instantiate the cost function for calculating infidelity coherently.</p> <p>This infidelity is defined as $$     F_{\\rm coherent} = |\\sum_{k}\\langle\\psi_{t}^{k}|\\psi_{i}^{k}(T)\\rangle|^2, $$ where the states at the end of the pulse are \\(|\\psi_{i}^{k}(T)\\rangle\\) and the target states are \\(|\\psi_{t}^{k}\\rangle\\).</p> <p>Parameters:</p> Name Type Description Default <code>target_states</code> <code>_(array_like of shape (s, n, 1) or (s, n, n))_</code> <p>target states for the initial states passed to <code>grape</code>. If performing master-equation optimization, the target states should be passed as a list of density matrices.</p> required <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.005</code> <p>Returns:</p> Type Description <code>CoherentInfidelity</code> <p>(CoherentInfidelity): Callable object that returns the coherent infidelity and whether the infidelity is below the target value.</p>"},{"location":"api/#qontrol.cost.control_area","title":"<code>control_area(cost_multiplier=1.0, target_cost=0.0)</code>","text":"<p>Control area cost function.</p> <p>Penalize the area under the pulse curves according to $$     C = \\sum_{j}\\int_{0}^{T}\\Omega_{j}(t)dt, $$ where the \\(\\Omega_{j}\\) are the individual controls and \\(T\\) is the pulse time.</p> <p>Parameters:</p> Name Type Description Default <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ControlCostArea</code> <p>(ControlArea): Callable object that returns the control-area cost and whether the cost is below the target value.</p>"},{"location":"api/#qontrol.cost.control_norm","title":"<code>control_norm(threshold, cost_multiplier=1.0, target_cost=0.0)</code>","text":"<p>Control norm cost function.</p> <p>Penalize the norm of the controls above some threshold according to $$     C = \\sum_{j}\\int_{0}^{T}ReLU(|\\Omega_{j}(t)|-\\Omega_{max})dt, $$ where the \\(\\Omega_{j}\\) are the individual controls, \\(T\\) is the pulse time and \\(\\Omega_{max}\\) is the threshold.</p> <p>Parameters:</p> Name Type Description Default <code>threshold</code> <code>_(float)_</code> <p>Threshold to use for penalizing amplitudes above this value in absolute magnitude.</p> required <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ControlCostNorm</code> <p>(ControlNorm): Callable object that returns the control-norm cost and whether the cost is below the target value.</p>"},{"location":"api/#qontrol.cost.custom_control_cost","title":"<code>custom_control_cost(cost_fun, cost_multiplier=1.0, target_cost=0.0)</code>","text":"<p>Cost function based on an arbitrary transformation of the controls.</p> <p>Penalize the controls according to an arbitrary function <code>F</code> $$     C = \\sum_{j}\\int_{0}^{T}F(\\Omega_{j}(t))dt, $$</p> <p>Parameters:</p> Name Type Description Default <code>cost_fun</code> <code>_(callable)_</code> <p>Cost function which must have signature <code>(control_amp: Array) -&gt; Array</code>.</p> required <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>CustomControlCost</code> <p>(CustomCost): Callable object that returns the cost for the custom function and whether the cost is below the target value.</p> <p>Examples:</p> <p><pre><code>def penalize_negative(control_amp: jax.Array) -&gt; jax.Array:\n    return jax.nn.relu(-control_amp)\n\n\nnegative_amp_cost = ql.custom_control_cost(penalize_negative)\n</code></pre> In this example, we penalize negative drive amplitudes.</p>"},{"location":"api/#qontrol.cost.custom_cost","title":"<code>custom_cost(cost_fun, cost_multiplier=1.0, target_cost=0.0)</code>","text":"<p>A custom cost function.</p> <p>In many (most!) cases, the user may want to add a cost function to their optimization that is not included in the hardcoded set of available cost functions.</p> <p>Parameters:</p> Name Type Description Default <code>cost_fun</code> <code>_(callable)_</code> <p>Cost function which must have signature <code>(result: dq.Result, H: dq.TimeArray, parameters: dict | Array) -&gt; Array</code>.</p> required <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>CustomCost</code> <p>(CustomCost): Callable object that returns the cost for the custom function.</p> <p>Examples:</p> <p>Let's imagine we want to penalize the value of some expectation value at the final time in <code>tsave</code>.</p> <p><pre><code>def penalize_expect(\n    result: Result, H: TimeArray, parameters: dict | Array\n) -&gt; Array:\n    # 0 is the index of the operator, -1 is the time index\n    return jnp.sum(jnp.abs(result.expects[0, -1]))\n\n\nexpect_cost = ql.custom_cost(penalize_expect)\n</code></pre> Then <code>expect_cost</code> can be added to the other utilized cost functions. The only thing happening under the hood is that the <code>penalize_expect</code> function is passed to <code>jax.tree_util.Partial</code> to enable it to be passed through jitted functions without issue.</p>"},{"location":"api/#qontrol.cost.forbidden_states","title":"<code>forbidden_states(forbidden_states_list, cost_multiplier=1.0, target_cost=0.0)</code>","text":"<p>Instantiate the cost function for penalizing forbidden-state occupation.</p> <p>This cost function is defined as $$     C = \\sum_{k}\\sum_{f}\\int_{0}^{T}dt|\\langle\\psi_{f}^{k}|\\psi_{i}^{k}(t)\\rangle|^2, $$ where \\(|\\psi_{i}^{k}(t)\\rangle\\) is the \\(k^{\\rm th}\\) initial state propagated to time \\(t\\) and |\\psi_{f}^{k}\\rangle is a forbidden state for the \\(k^{\\rm th}\\) initial state.</p> <p>Parameters:</p> Name Type Description Default <code>forbidden_states_list</code> <code>_(list of list of array-like of shape (n, 1) or (n, n))_</code> <p>For each initial state indexed by s (outer list), a list of forbidden states (inner list) should be provided. The inner lists need not all be of the same shape, for instance if some initial states have more forbidden states than others. The array is eventually reshaped to have shape (s, f, n, 1) or (s, f, n, n) (for <code>sesolve</code> or <code>mesolve</code>, respectively) where s is the number of initial states and f is the length of the longest forbidden-state list (with zero-padding for meaningless entries).</p> required <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>ForbiddenStates</code> <p>(ForbiddenStates): Callable object that returns the forbidden-state cost and whether the cost is below the target value.</p>"},{"location":"api/#qontrol.cost.incoherent_infidelity","title":"<code>incoherent_infidelity(target_states, cost_multiplier=1.0, target_cost=0.005)</code>","text":"<p>Instantiate the cost function for calculating infidelity incoherently.</p> <p>This infidelity is defined as $$     F_{\\rm incoherent} = \\sum_{k}|\\langle\\psi_{t}^{k}|\\psi_{i}^{k}(T)\\rangle|^2, $$ where the states at the end of the pulse are \\(|\\psi_{i}^{k}(T)\\rangle\\) and the target states are \\(|\\psi_{t}^{k}\\rangle\\).</p> <p>Parameters:</p> Name Type Description Default <code>target_states</code> <code>_(array_like of shape (s, n, 1) or (s, n, n))_</code> <p>target states for the initial states passed to <code>grape</code>. If performing master-equation optimization, the target states should be passed as a list of density matrices.</p> required <code>cost_multiplier</code> <code>_(float)_</code> <p>Weight for this cost function relative to other cost functions.</p> <code>1.0</code> <code>target_cost</code> <code>_(float)_</code> <p>Target value for this cost function. If options.all_costs is True, the optimization terminates early if all cost functions fall below their target values. If options.all_costs is False, the optimization terminates if only one cost function falls below its target value.</p> <code>0.005</code> <p>Returns:</p> Type Description <code>IncoherentInfidelity</code> <p>(IncoherentInfidelity): Callable object that returns the incoherent infidelity and whether the infidelity is below the target value.</p>"},{"location":"api/#models","title":"Models","text":""},{"location":"api/#qontrol.model.MESolveModel","title":"<code>MESolveModel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model for Lindblad-master-equation optimization.</p> <p>When called with the parameters we optimize over returns the results of <code>mesolve</code> as well as the updated Hamiltonian.</p>"},{"location":"api/#qontrol.model.SESolveModel","title":"<code>SESolveModel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Model for Schr\u00f6dinger-equation optimization.</p> <p>When called with the parameters we optimize over returns the results of <code>sesolve</code> as well as the updated Hamiltonian.</p>"},{"location":"api/#qontrol.model.mesolve_model","title":"<code>mesolve_model(H_function, jump_ops, rho0, tsave_or_function, *, exp_ops=None)</code>","text":"<p>Instantiate mesolve model.</p> <p>Here we instantiate the model that is called at each step of the optimization iteration, returning a tuple of the result of calling <code>mesolve</code> as well as the Hamiltonian evaluated at the parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>H_function</code> <code>_(callable)_</code> <p>function specifying how to update the Hamiltonian</p> required <code>jump_ops</code> <code>_(list of array-like or time-array, each of shape (...Lk, n, n))_</code> <p>List of jump operators.</p> required <code>rho0</code> <code>_(ArrayLike of shape (..., n, n))_</code> <p>Initial density matrices.</p> required <code>tsave_or_function</code> <code>_(ArrayLike of shape (ntsave,) or callable)_</code> <p>Either an array of times passed to sesolve or a method specifying how to update the times that are passed to sesolve</p> required <code>exp_ops</code> <code>_(list of array-like)_</code> <p>Operators to calculate expectation values of, in case some of the cost functions depend on the value of certain expectation values.</p> <code>None</code> <p>Returns:</p> Type Description <code>MESolveModel</code> <p>(MESolveModel): Model that when called with the parameters we optimize over as argument returns the results of <code>mesolve</code> as well as the updated Hamiltonian</p> <p>Examples:</p> <p>Instantiating a <code>MESolveModel</code> is quite similar to instantiating an <code>SESolveModel</code>, with the two differences being that we need to supply jump operators, and the initial and target states should be specified as density matrices. Continuing the last example from <code>sesolve_model</code> <pre><code>jump_ops = [0.03 * dq.sigmax()]\nme_initial_states = dq.todm(psi0)\nme_Kerr_model = ql.mesolve_model(\n    update_H_topt, jump_ops, me_initial_states, update_tsave_topt\n)\n</code></pre> See this tutorial for example</p>"},{"location":"api/#qontrol.model.sesolve_model","title":"<code>sesolve_model(H_function, psi0, tsave_or_function, *, exp_ops=None)</code>","text":"<p>Instantiate sesolve model.</p> <p>Here we instantiate the model that is called at each step of the optimization iteration, returning a tuple of the result of calling <code>sesolve</code> as well as the Hamiltonian evaluated at the parameter values.</p> <p>Parameters:</p> Name Type Description Default <code>H_function</code> <code>_(callable)_</code> <p>function specifying how to update the Hamiltonian</p> required <code>psi0</code> <code>_(ArrayLike of shape (..., n, 1))_</code> <p>Initial states.</p> required <code>tsave_or_function</code> <code>_(ArrayLike of shape (ntsave,) or callable)_</code> <p>Either an array of times passed to sesolve or a method specifying how to update the times that are passed to sesolve</p> required <code>exp_ops</code> <code>_(list of array-like)_</code> <p>Operators to calculate expectation values of, in case some of the cost functions depend on the value of certain expectation values.</p> <code>None</code> <p>Returns:</p> Type Description <code>SESolveModel</code> <p>(SESolveModel): Model that when called with the parameters we optimize over as argument returns the results of <code>sesolve</code> as well as the updated Hamiltonian</p> <p>Examples:</p> <p>In this simple example the parameters are the amplitudes of piecewise-constant controls <pre><code>tsave = jnp.linspace(0.0, 11.0, 10)\npsi0 = [dq.basis(2, 0)]\nH1s = [dq.sigmax(), dq.sigmay()]\n\n\ndef H_pwc(values: Array) -&gt; dq.TimeArray:\n    H = dq.sigmaz()\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, values[idx], _H1)\n    return H\n\n\nsesolve_model = ql.sesolve_model(H_pwc, psi0, tsave)\n</code></pre> See for example this tutorial.</p> <p>In more complex cases, we can imagine that the optimized parameters are the control points fed into a spline, and additionally the control times themselves are optimized. <pre><code>init_drive_params_topt = {\n    'dp': -0.001 * jnp.ones((len(H1s), len(tsave))),\n    't': tsave[-1],\n}\n\n\ndef H_func_topt(t: float, drive_params_dict: dict) -&gt; dq.TimeArray:\n    drive_params = drive_params_dict['dp']\n    new_tsave = jnp.linspace(0.0, drive_params_dict['t'], len(tsave))\n    drive_spline = _drive_spline(drive_params, envelope, new_tsave)\n    drive_amps = drive_spline.evaluate(t)\n    drive_Hs = jnp.einsum('d,dij-&gt;ij', drive_amps, H1s)\n    return H0 + drive_Hs\n\n\ndef update_H_topt(drive_params_dict: dict) -&gt; dq.TimeArray:\n    new_H = jtu.Partial(H_func_topt, drive_params_dict=drive_params_dict)\n    return dq.timecallable(new_H)\n\n\ndef update_tsave_topt(drive_params_dict: dict) -&gt; jax.Array:\n    return jnp.linspace(0.0, drive_params_dict['t'], len(tsave))\n\n\nse_t_opt_Kerr_model = ql.sesolve_model(update_H_topt, psi0, update_tsave_topt)\n</code></pre> See for example this tutorial.</p>"},{"location":"api/#options","title":"Options","text":""},{"location":"api/#qontrol.options.OptimizerOptions","title":"<code>OptimizerOptions</code>","text":"<p>               Bases: <code>Options</code></p> <p>Subclass of dynamiqs Options to allow for various optimizer options.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>_(bool)_</code> <p>If <code>True</code>, the optimizer will print out the infidelity at each epoch step to track the progress of the optimization.</p> <code>True</code> <code>all_costs</code> <code>_(bool)_</code> <p>Whether or not all costs must be below their targets for early termination of the optimizer. If False, the optimization terminates if only one cost function is below the target (typically infidelity).</p> <code>True</code> <code>epochs</code> <code>_(int)_</code> <p>Number of optimization epochs.</p> <code>2000</code> <code>plot</code> <code>_(bool)_</code> <p>Whether to plot the results during the optimization (for the epochs where results are plotted, necessarily suffer a time penalty).</p> <code>True</code> <code>plot_period</code> <code>_(int)_</code> <p>If plot is True, plot every plot_period.</p> <code>30</code> <code>which_states_plot</code> <code>_(tuple)_</code> <p>Which states to plot if expectation values are passed to the model. Defaults to (0, ), so just plot expectation values for the zero indexed batch state</p> <code>(0)</code> <code>xtol</code> <code>_(float)_</code> <p>Defaults to 1e-8, terminate the optimization if the parameters are not being updated</p> <code>1e-08</code> <code>ftol</code> <code>_(float)_</code> <p>Defaults to 1e-8, terminate the optimization if the cost function is not changing above this level</p> <code>1e-08</code> <code>gtol</code> <code>_(float)_</code> <p>Defaults to 1e-8, terminate the optimization if the norm of the gradient falls below this level</p> <code>1e-08</code>"},{"location":"api/#file-utilities","title":"File utilities","text":""},{"location":"examples/Kerr_oscillator/","title":"Kerr Oscillator","text":"<pre><code>import diffrax as dx\nimport dynamiqs as dq\nimport jax.numpy as jnp\nimport optax\nfrom jax import Array\n\nimport qontrol as ql\n</code></pre> <pre><code>time = 20.0\ncontrol_dt = 2.0\nramp_nts = 4\nntimes = int(time // control_dt) + 1\ntsave = jnp.linspace(0, time, ntimes)\noptimizer = optax.adam(learning_rate=0.001, b1=0.999, b2=0.999)\noptions = ql.OptimizerOptions(\n    verbose=False,\n    save_states=True,\n    progress_meter=None,\n    epochs=4000,\n    plot=True,\n    plot_period=20,\n)\n</code></pre> <p>We define our Kerr oscillator to have a 100 MHz Kerr. We optimize the drive envelopes on the I and Q quadratures.</p> <pre><code>dim = 5\nKerr = -2.0 * jnp.pi * 0.100\na = dq.destroy(dim)\nH0 = -0.5 * Kerr * dq.dag(a) @ dq.dag(a) @ a @ a\nH1s = [a + dq.dag(a), 1j * (a - dq.dag(a))]\nH1_labels = ['I', 'Q']\n</code></pre> <p>Here we attempt to perform an <code>X</code> gate, and penalize population leaking to the higher-lying states</p> <pre><code>initial_states = [dq.basis(dim, 0), dq.basis(dim, 1)]\nfinal_states = [dq.basis(dim, 1), dq.basis(dim, 0)]\n_forbidden_states = [dq.basis(dim, idx) for idx in range(2, dim)]\nforbidden_states_list = len(initial_states) * [_forbidden_states]\n</code></pre> <p>We initialize the guess for the controls and moreover define an envelope of cosine ramps with a flat top to ensure that the control turns on slowly.</p> <pre><code>init_drive_params = {'dp': -0.001 * jnp.ones((len(H1s), ntimes))}\n\ncos_ramp = (1 - jnp.cos(jnp.linspace(0.0, jnp.pi, ramp_nts))) / 2\nenvelope = jnp.concatenate(\n    (cos_ramp, jnp.ones(ntimes - 2 * ramp_nts), jnp.flip(cos_ramp))\n)\n\n\ndef _drive_spline(\n    drive_params: Array, envelope: Array, ts: Array\n) -&gt; dx.CubicInterpolation:\n    drive_w_envelope = jnp.einsum('t,...t-&gt;t...', envelope, drive_params)\n    drive_coeffs = dx.backward_hermite_coefficients(ts, drive_w_envelope)\n    return dx.CubicInterpolation(ts, drive_coeffs)\n\n\ndef H_func(drive_params_dict: dict) -&gt; dq.TimeArray:\n    drive_params = drive_params_dict['dp']\n    H = H0\n    for H1, drive_param in zip(H1s, drive_params):\n        drive_spline = _drive_spline(drive_param, envelope, tsave)\n        H += dq.modulated(drive_spline.evaluate, H1)\n    return H\n\n\nexp_ops = [dq.basis(dim, idx) @ dq.dag(dq.basis(dim, idx)) for idx in range(dim)]\n\nse_Kerr_model = ql.sesolve_model(H_func, initial_states, tsave, exp_ops=exp_ops)\n</code></pre> <pre><code>costs = ql.coherent_infidelity(target_states=final_states, target_cost=0.005)\ncosts += 40.0 * ql.forbidden_states(\n    forbidden_states_list=forbidden_states_list, target_cost=0.4\n)\n</code></pre> <pre><code>opt_params = ql.optimize(\n    init_drive_params, costs, model=se_Kerr_model, optimizer=optimizer, options=options\n)\n</code></pre> <pre>\n<code>target cost reached for all cost functions;\noptimization terminated after 127 epochs; \naverage epoch time (excluding jit) of 0.001 s; \nmax epoch time of 0.001 s; \nmin epoch time of 0.001 s\n</code>\n</pre> <p>Try playing with the <code>cost_multiplier</code> of the forbidden states cost function to see how it modifies the pulse! Specifically, try setting it to 0 so that the optimizer is happy to populate the 2nd excited state without penalty.</p> <pre><code>jump_ops = [0.01 * a]\nme_initial_states = dq.todm(initial_states)\nme_final_states = dq.todm(final_states)\nme_forbidden_states_list = len(initial_states) * [dq.todm(_forbidden_states)]\nme_costs = ql.coherent_infidelity(target_states=me_final_states, target_cost=0.005)\nme_costs += 40.0 * ql.forbidden_states(\n    forbidden_states_list=me_forbidden_states_list, target_cost=0.4\n)\n\nme_Kerr_model = ql.mesolve_model(\n    H_func, jump_ops, me_initial_states, tsave, exp_ops=exp_ops\n)\n</code></pre> <pre><code>opt_params_me = ql.optimize(\n    init_drive_params, me_costs, me_Kerr_model, optimizer=optimizer, options=options\n)\n</code></pre> <pre>\n<code>target cost reached for all cost functions;\noptimization terminated after 412 epochs; \naverage epoch time (excluding jit) of 0.0021 s; \nmax epoch time of 0.004 s; \nmin epoch time of 0.002 s\n</code>\n</pre>"},{"location":"examples/Kerr_oscillator/#optimization-for-a-kerr-oscillator","title":"Optimization for a Kerr oscillator","text":"<p>In this example we will try to implement DRAG-like pulses on a Kerr oscillator, penalizing population going to leakage states. We will additionally use a slightly more complicated control scheme than in the qubit example. There we performed traditional grape, with piecewise-constant controls. Here we fit a spline to control knot points: it is these knot points that are optimized.</p> <p>This technique has the benefit of ensuring smooth controls if the control points are spread far enough apart in time, which is not guaranteed in the case of piece-wise constant controls. It is important to emphasize here that the control points are in no way related to the points chosen by the numerical integrator for solving the differential equation! This is a significant difference from typical QOC/GRAPE implementations that perform numerical integration of the Schr\u00f6dinger equation by calculating step propagators with sufficiently small time steps.</p> <p>This example is available as a Jupyter notebook here.</p>"},{"location":"examples/Kerr_oscillator/#master-equation-optimization","title":"Master-equation optimization","text":"<p>We can also instead perform the optimization directly on the master equation. Continuing the above example, we need now to initialize an <code>mesolve_model</code>, which calls <code>dq.mesolve</code>, and to correctly specify the initial and target states as density matrices.</p>"},{"location":"examples/qubit/","title":"Qubit","text":"<pre><code>import dynamiqs as dq\nimport jax.numpy as jnp\nimport optax\nfrom jax import Array\nfrom jax.random import normal, PRNGKey\n\nimport qontrol as ql\n</code></pre> <pre><code>time = 30\ncontrol_dt = 2.0\nntimes = int(time // control_dt) + 1\noptimizer = optax.adam(learning_rate=0.001, b1=0.99, b2=0.99)\ntsave = jnp.linspace(0, time, ntimes)\noptions = ql.OptimizerOptions(\n    verbose=False,\n    save_states=False,\n    progress_meter=None,\n    epochs=4000,\n    plot=True,\n    plot_period=200,\n)\n</code></pre> <p>Here we initialize the random qubit frequency fluctuations pulled from a normal distribution. Note that the drive is on resonance with the average value of the qubit frequency.</p> <pre><code>key = PRNGKey(42)\nrandom_freqs = 2.0 * jnp.pi * normal(key, shape=(21,)) / 500\nH0 = random_freqs[:, None, None] * dq.sigmaz()[None]\nH1s = [dq.sigmax(), dq.sigmay()]\nH1_labels = ['X', 'Y']\n</code></pre> <p>Here we define what final states the initial states should map to. In this case we want to achieve a Y gate</p> <pre><code>initial_states = [dq.basis(2, 0), dq.basis(2, 1)]\ntarget_states = [-1j * dq.basis(2, 1), 1j * dq.basis(2, 0)]\n</code></pre> <p>We next initialize our first guess for the controls and define the function that, given the controls, returns the Hamiltonian.</p> <pre><code>init_drive_params = -0.001 * jnp.ones((len(H1s), ntimes - 1))\n\n\ndef H_pwc(values: Array) -&gt; dq.TimeArray:\n    H = H0\n    for idx, _H1 in enumerate(H1s):\n        H += dq.pwc(tsave, values[idx], _H1)\n    return H\n\n\nexp_ops = [dq.basis(2, 1) @ dq.dag(dq.basis(2, 1))]\nsesolve_model = ql.sesolve_model(H_pwc, initial_states, tsave, exp_ops=exp_ops)\n</code></pre> <p>In this example we use the coherent definition of the infidelity and penalize drive strengths above 16 MHz</p> <pre><code>costs = ql.coherent_infidelity(target_states=target_states, target_cost=0.001)\ncosts += ql.control_norm(2.0 * jnp.pi * 0.016, target_cost=0.1)\n</code></pre> <pre><code>opt_params = ql.optimize(\n    init_drive_params, costs, sesolve_model, optimizer=optimizer, options=options\n)\n</code></pre> <pre>\n<code>target cost reached for all cost functions;\noptimization terminated after 1028 epochs; \naverage epoch time (excluding jit) of 0.00256 s; \nmax epoch time of 0.01 s; \nmin epoch time of 0.002 s\n</code>\n</pre> <p>We see that despite the MHz-level frequency variations of the qubit frequency, the obtained pulse succesfully performs the desired state transfer! Here we plot the population in the \\(|1\\rangle\\) state when beginning in the \\(|0\\rangle\\) state for the different batch instances</p>"},{"location":"examples/qubit/#grape-on-a-qubit-with-an-uncertain-frequency","title":"GRAPE on a qubit with an uncertain frequency","text":"<p>Lets start with the example of GRAPE on a qubit, optimizing the drive envelope to be robust to variations in qubit frequency. This example will illustrate the utility of batching, allowing us to average over many different qubit frequencies to obtain a pulse that achieves a high-fidelity gate and is robust to frequency fluctuations.</p> <p>This example is available as a Jupyter notebook here.</p>"}]}